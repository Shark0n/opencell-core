<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.5.xsd">

    <changeSet id="#4140_08042019" author="hznibar">
			<modifyDataType tableName="wf_history_action" columnName="result" newDataType="varchar(2000)" />
	</changeSet>
	
	<changeSet id="#4127_10042019" author="AbdelmounaimAkadid">
		<addColumn tableName="dwh_report_extract">
            <column name="output_dir" type="varchar(255)" />
        </addColumn>
        <sql>update ${db.schema.adapted}dwh_report_extract set output_dir = concat('reports/', category) where category is not null or category != ''
        </sql>
        <sql>update ${db.schema.adapted}dwh_report_extract set output_dir = 'reports' where category is null or category = ''
        </sql>
	</changeSet>

	<changeSet id="#4127_10042019" author="AbdelmounaimAkadid">
		<addColumn tableName="dwh_report_extract">
            <column name="output_dir" type="varchar(255)" />
        </addColumn>
        <sql>update ${db.schema.adapted}dwh_report_extract set output_dir = concat('reports/', category) where category is not null or category != ''
        </sql>
        <sql>update ${db.schema.adapted}dwh_report_extract set output_dir = 'reports' where category is null or category = ''
        </sql>
	</changeSet>

    <changeSet id="#4089_20190404" author="AbdellatifBARI">
        <sql>update ${db.schema.adapted}crm_custom_field_tmpl set applies_to = case

            when applies_to = 'PROVIDER'                then 'Provider'
            when applies_to = 'PRODUCT'                 then 'ProductTemplate'
            when applies_to = 'PRODUCT_INSTANCE'        then 'ProductInstance'
            when applies_to = 'OFFER'                   then 'OfferTemplate'
            when applies_to = 'SELLER'                  then 'Seller'
            when applies_to = 'CUST'                    then 'Customer'
            when applies_to = 'CA'                      then 'CustomerAccount'
            when applies_to = 'BA'                      then 'BillingAccount'
            when applies_to = 'UA'                      then 'UserAccount'
            when applies_to = 'SERVICE'                 then 'ServiceTemplate'
            when applies_to = 'SERVICE_INSTANCE'        then 'ServiceInstance'
            when applies_to = 'SUB'                     then 'Subscription'
            when applies_to = 'ACC'                     then 'Access'
            when applies_to = 'CHARGE'                  then 'ChargeTemplate'
            when applies_to = 'PRICEPLAN'               then 'PricePlanMatrix'

            when applies_to = 'BILLING_CYCLE'           then 'BillingCycle'
            when applies_to = 'TAX'                     then 'Tax'
            when applies_to = 'INV_CAT'                 then 'InvoiceCategory'
            when applies_to = 'INVOICE'                 then 'Invoice'
            when applies_to = 'ACCT_CODE'               then 'AccountingCode'
            when applies_to = 'FILTER'                  then 'Filter'
            when applies_to = 'QUOTE'                   then 'Quote'
            when applies_to = 'ORDER'                   then 'Order'
            when applies_to = 'USER'                    then 'User'
            when applies_to = 'JOB'                     then 'JobInstance'
            when applies_to = 'DISCOUNT_PLAN_INSTANCE'  then 'DiscountPlanInstance'
            when applies_to = 'DISCOUNT_PLAN'           then 'DiscountPlan'
            when applies_to = 'OFFER_CATEGORY'          then 'OfferTemplateCategory'
            when applies_to = 'INV_SUB_CAT'             then 'InvoiceSubCategory'
            when applies_to = 'ACC_OP'                  then 'AccountOperation'

            when applies_to = 'BILLING_RUN'             then 'BillingRun'
            when applies_to = 'INVOICE_TYPE'            then 'InvoiceType'
            when applies_to = 'DISCOUNT_PLAN_ITEM'      then 'DiscountPlanItem'
            when applies_to = 'OTH_TR'                  then 'OtherTransaction'
            when applies_to = 'REPORT'                  then 'ReportExtract'
            when applies_to = 'BUNDLE'                  then 'BundleTemplate'
            when applies_to = 'PAYMENT_SCH_INSTANCE'    then 'PaymentScheduleInstance'
            when applies_to = 'DDREQ_BUILDER'           then 'DDRequestBuilder'
            when applies_to = 'PAYMENT_SCH'             then 'PaymentScheduleTemplate'

            when applies_to like 'JOB_%'                then  concat('JobInstance_', substring(applies_to, length('JOB_')+1, length(applies_to)))

            else applies_to

            end where applies_to is not null
        </sql>
    </changeSet>

	<changeSet id="#4107_20190515" author="EdwardPLegaspi">
		<createTable tableName="adm_role_secured_entity">
			<column name="role_id" type="bigint">
				<constraints nullable="false" />
			</column>
			<column name="code" type="varchar(255)">
				<constraints nullable="false" />
			</column>
			<column name="entity_class" type="varchar(255)">
				<constraints nullable="false" />
			</column>
		</createTable>
		<addPrimaryKey columnNames="role_id, code, entity_class"
			constraintName="adm_role_secured_entity_pkey"
			tableName="adm_role_secured_entity" />
	</changeSet>
    
    <changeSet id="#4117_20190405" author="AmineBENAICHA">
    	<addColumn tableName="wf_instance">
            <column name="entity_instance_id" type="bigint" >
            	<constraints nullable="false" />
            </column>
        </addColumn>
        <createIndex tableName="wf_instance" indexName="wf_instance_entity_id_idx">
            <column name="entity_instance_id" type="bigint"/>
        </createIndex>
    </changeSet>

    <changeSet id="#4179_20190417" author="AndriusKarpavicius">
        <addColumn tableName="meveo_script_instance">
            <column name="reuse" type="${type.boolean}" defaultValueNumeric="0"/>
        </addColumn>
    </changeSet>
    
    <changeSet id="#4148_20190418 - Add runAsync on notification" author="EdwardPLegaspi">
    	<addColumn tableName="adm_notification">
            <column name="run_async" type="${type.boolean}" defaultValueNumeric="0"/>
        </addColumn>
    </changeSet>
    
    <changeSet id="#3683_20190415" author="YoussefIZEM">
         <addColumn tableName="adm_notif_email">
            <column name="email_template_id" type="bigint"></column>
        </addColumn>
         <addColumn tableName="adm_notification">
            <column name="cf_values_accum" type="${type.json}"></column>
            <column name="cf_values" type="${type.json}"></column>
            <column name="uuid" type="varchar(60)" />
        </addColumn>
        <sql>update ${db.schema.adapted}adm_notification set uuid = id</sql>
        <sql>update ${db.schema.adapted}adm_notif_email set email_template_id=NEXTVAL('${db.schema.adapted}com_msg_tmpl_seq')</sql>
        <sql>
            INSERT INTO ${db.schema.adapted}com_message_template(id, version, created, code, subject, textcontent, htmlcontent, media)   
            SELECT email_template_id, 0, now(), notif.code, email_subject, email_body, email_html_body, 'EMAIL' as media
            FROM ${db.schema.adapted}adm_notif_email email
            LEFT JOIN ${db.schema.adapted}adm_notification notif  on notif.id = email.id
        </sql>
        <addForeignKeyConstraint baseColumnNames="email_template_id" baseTableName="adm_notif_email" constraintName="fk_com_message_template" deferrable="false" initiallyDeferred="false"
            onDelete="NO ACTION" onUpdate="NO ACTION" referencedColumnNames="id" referencedTableName="com_message_template" />
                    
        <dropColumn tableName="adm_notif_email">
            <column name="email_body"></column>
            <column name="email_html_body"></column>
            <column name="email_subject"></column>
        </dropColumn>
     </changeSet>
     
     <changeSet id="#4208_2019042601" author="MohamedElYoussoufi" dbms="postgresql" >
     	
        <sql>CREATE INDEX cust_cei_cet_and_code_index ON ${db.schema.adapted}cust_cei((lower(cet_code)),(lower(code)));</sql>
        
     </changeSet>
     
     <changeSet id="#4208_2019042602" author="MohamedElYoussoufi" dbms="mysql">
     	
        <sql>CREATE INDEX cust_cei_cet_and_code_index ON ${db.schema.adapted}cust_cei(cet_code,code);</sql>
     	
     </changeSet>
     
     
     <changeSet id="#3692_20190426" author="AndriusKarpavicius">
        <modifyDataType tableName="ar_payment_gateway" columnName="iban" newDataType="varchar(80)" />
    </changeSet>
    
    <changeSet id="#4207_2019042901" author="MohamedElYoussoufi">
     	
     	<addColumn tableName="billing_rated_transaction">
            <column name="offer_id" type="bigint"></column>
        </addColumn>
        
        <addForeignKeyConstraint baseColumnNames="offer_id" baseTableName="billing_rated_transaction" constraintName="fk_billing_rated_transaction_offer_template" deferrable="false"
            initiallyDeferred="false" onDelete="NO ACTION" onUpdate="NO ACTION" referencedColumnNames="id" referencedTableName="cat_offer_template" />
            
        <addColumn tableName="billing_wallet_operation">
            <column name="offer_id" type="bigint"></column>
        </addColumn>
        
        <addForeignKeyConstraint baseColumnNames="offer_id" baseTableName="billing_wallet_operation" constraintName="fk_billing_wallet_operation_offer_template" deferrable="false"
            initiallyDeferred="false" onDelete="NO ACTION" onUpdate="NO ACTION" referencedColumnNames="id" referencedTableName="cat_offer_template" />
            
        <sql>
        	update ${db.schema.adapted}billing_wallet_operation set offer_code = null where offer_code = 'NO_OFFER';
        </sql>
          
      </changeSet>
      
      <changeSet id="#4207_2019042902" author="MohamedElYoussoufi" dbms="postgresql">
      
        <sql>
        	 	update ${db.schema.adapted}billing_rated_transaction rt set offer_id = (select s.offer_id from ${db.schema.adapted}billing_subscription s where s.id=rt.subscription_id and rt.subscription_id is not null)
        </sql>
        
        <sql>
        		update ${db.schema.adapted}billing_wallet_operation wo set offer_id = (select s.offer_id from ${db.schema.adapted}billing_subscription s where s.id=wo.subscription_id and wo.subscription_id is not null)
        </sql>
      
      </changeSet>
      
      <changeSet id="#4207_2019042903" author="MohamedElYoussoufi" dbms="mysql">
      
      	<sql>
        	 update ${db.schema.adapted}billing_rated_transaction rt join ${db.schema.adapted}billing_subscription s on s.id=rt.subscription_id  set offer_id = s.offer_id where rt.subscription_id is not null
        </sql>
        
        <sql>
        	update ${db.schema.adapted}billing_wallet_operation wo join ${db.schema.adapted}billing_subscription s on s.id=wo.subscription_id  set offer_id = s.offer_id where wo.subscription_id is not null
		</sql>
      
      </changeSet>
      
      <changeSet id="#4207_2019042904" author="MohamedElYoussoufi">
      	<dropColumn tableName="billing_rated_transaction">
            <column name="offer_code"></column>
        </dropColumn>
      </changeSet>

	<changeSet id="#4156_20190423" author="EdwardPLegaspi">
		<addColumn tableName="meveo_job_instance">
			<column name="verbose_report" type="${type.boolean}"
				defaultValueNumeric="1" />
		</addColumn>

		<update tableName="meveo_job_instance">
			<column name="verbose_report" valueNumeric="1"></column>
		</update>
	</changeSet>
    
    <changeSet id="#4198_03052019" author="SaidRamli">
       <addColumn tableName="billing_invoice_type">
           <column name="invoice_accountable" type="${type.boolean}" defaultValueNumeric="1">
		        <constraints nullable="false" />
		    </column>
       </addColumn>
        <sql>update ${db.schema.adapted}billing_invoice_type set invoice_accountable = 1 where code not in ('QUOTE','DRAFT','PREPAID')</sql>
        <sql>update ${db.schema.adapted}billing_invoice_type set invoice_accountable = 0 where code in ('QUOTE','DRAFT','PREPAID')</sql>
    </changeSet>

    <changeSet id="#4156_08052019" author="AndriusKarpavicius">
        <addDefaultValue tableName="meveo_job_instance" columnName="exclude_inv_without_amount" defaultValueNumeric="0" />
        <sql>update ${db.schema.adapted}meveo_job_instance set exclude_inv_without_amount = 0 where exclude_inv_without_amount is null</sql>
    </changeSet>
    
    <changeSet id="#4278_20190516_partitions" author="mohamed.el.youssoufi" dbms="postgresql">
    
		<createProcedure><![CDATA[
			CREATE OR REPLACE FUNCTION switch_billing_rated_transaction_to_partition(schema_owner text, schema_name text, frequency text) RETURNS void AS $$
			
			-- Function to replace billing_rated_transaction table with a partitioned table. Preserves existing data.
			-- Param1 : schema_name => name of the schema where table is located.
			-- Param2 : frequency => interval of partionning ( Y for years, M for monthes, W for weeks). If provided, partitions will be created to span the current data in a table
			
			DECLARE
			  _min_date date;
			  _max_date date;
			  _seq_value bigint;
			  _partitions_number int;
			
			BEGIN
			
			-- Find values for partition creation and sequence recreation
			execute 'select min(usage_date), max(usage_date) from ' || schema_name || '.billing_rated_transaction ' into _min_date, _max_date;
			execute 'select nextval(''' || schema_name || '.billing_rated_transaction_seq'')' into _seq_value;
			
			RAISE NOTICE 'min date is % max date is %', _min_date, _max_date;
			-- Rename existing table to a temp table
			execute 'alter table '||schema_name||'.billing_rated_transaction rename to billing_rated_transaction_tmp;';
			execute 'alter index '||schema_name||'.billing_rated_transaction_pkey rename to billing_rated_transaction_pkey_tmp;';
			execute 'alter index '||schema_name||'.rated_transaction_number rename to rated_transaction_number_tmp;';
			--execute 'alter index '||schema_name||'.rated_transaction_sub rename to rated_transaction_sub_tmp;';
			execute 'alter index '||schema_name||'.transaction_billing_account_index rename to transaction_billing_account_index_tmp;';
			execute 'alter index '||schema_name||'.transaction_billing_index rename to transaction_billing_index_tmp;';
			
			-- Create new partitioned table
			execute 'create table '||schema_name||'.billing_rated_transaction (
			  id bigint not null default nextval('''||schema_name||'.billing_rated_transaction_seq''::regclass),
			  version integer,
			  amount_tax numeric(23,12),
			  amount_with_tax numeric(23,12),
			  amount_without_tax numeric(23,12),
			  code character varying(255),
			  description text,
			  do_not_trigger_invoicing integer not null default 0,
			  parameter_1 character varying(255),
			  parameter_2 character varying(255),
			  parameter_3 character varying(255),
			  quantity numeric(23,12),
			  status character varying(255),
			  unit_amount_tax numeric(23,12),
			  unit_amount_with_tax numeric(23,12),
			  unit_amount_without_tax numeric(23,12),
			  unity_description character varying(20),
			  usage_date timestamp without time zone,
			  billing_account__id bigint,
			  billing_run_id bigint,
			  invoice_id bigint,
			  aggregate_id_f bigint,
			  aggregate_id_r bigint,
			  aggregate_id_t bigint,
			  invoice_sub_category_id bigint,
			  priceplan_id bigint,
			  wallet_id bigint,
			  edr_id bigint,
			  adjusted_rated_tx bigint,
			  order_number character varying(100),
			  rating_unit_description character varying(20),
			  parameter_extra text,
			  start_date timestamp without time zone,
			  end_date timestamp without time zone,
			  subscription_id bigint,
			  seller_id bigint not null,
			  charge_instance_id bigint,
			  tax_id bigint,
			  tax_percent numeric(23,12),
			  user_account_id bigint,
			  offer_id bigint,
			  constraint billing_rated_transaction_pkey primary key (id, usage_date),
			  constraint fk_8g8jlmakt1wyw73oxs5yltlsd foreign key (aggregate_id_t)
			      references '||schema_name||'.billing_invoice_agregate (id) match simple
			      on update no action on delete no action,
			  constraint fk_amwacie0nqfumpd1sc7y9nv0p foreign key (aggregate_id_r)
			      references '||schema_name||'.billing_invoice_agregate (id) match simple
			      on update no action on delete no action,
			  constraint fk_anslvrbm465ossqx8surjyu22 foreign key (wallet_id)
			      references '||schema_name||'.billing_wallet (id) match simple
			      on update no action on delete no action,
			  constraint fk_bbnhg8vn7jkttghphr65iwug5 foreign key (billing_account__id)
			      references '||schema_name||'.billing_billing_account (id) match simple
			      on update no action on delete no action,
			  constraint fk_billing_rated_transaction_crm_seller foreign key (seller_id)
			      references '||schema_name||'.crm_seller (id) match simple
			      on update no action on delete no action,
			  constraint fk_billing_rated_transaction_offer_template foreign key (offer_id)
			      references '||schema_name||'.cat_offer_template (id) match simple
			      on update no action on delete no action,
			  constraint fk_eucl7of9ovyut1c4r2jkf01u6 foreign key (priceplan_id)
			      references '||schema_name||'.cat_price_plan_matrix (id) match simple
			      on update no action on delete no action,
			  constraint fk_gq86s178gc3orumcl8symk4nn foreign key (invoice_id)
			      references '||schema_name||'.billing_invoice (id) match simple
			      on update no action on delete no action,
			  constraint fk_o2mp1mqcyi2l7q2b1p88h20dw foreign key (billing_run_id)
			      references '||schema_name||'.billing_billing_run (id) match simple
			      on update no action on delete no action,
			  constraint fk_o5yu3c0bnac626w755w5f0voc foreign key (invoice_sub_category_id)
			      references '||schema_name||'.billing_invoice_sub_cat (id) match simple
			      on update no action on delete no action,
			  constraint fk_rjpm9k6xsumg297fxefffyryh foreign key (aggregate_id_f)
			      references '||schema_name||'.billing_invoice_agregate (id) match simple
			      on update no action on delete no action,
			  constraint fk_rt_tax foreign key (tax_id)
			      references '||schema_name||'.billing_tax (id) match simple
			      on update no action on delete no action,
			  constraint fk_rt_ua foreign key (user_account_id)
			      references '||schema_name||'.account_entity (id) match simple
			      on update no action on delete no action
			) partition by range (usage_date)';
			
			-- execute 'alter table '||schema_name||'.billing_rated_transaction owner to '||schema_owner||';';
			
			-- Create indexes
			execute 'create index rated_transaction_u_date on '||schema_name||'.billing_rated_transaction using btree (usage_date);';
			execute 'create index rated_transaction_number on '||schema_name||'.billing_rated_transaction using btree (usage_date, order_number);';
			execute 'create index rated_transaction_sub on '||schema_name||'.billing_rated_transaction using btree (usage_date, subscription_id);';
			execute 'create index transaction_billing_account_index on '||schema_name||'.billing_rated_transaction using btree (usage_date, billing_account__id);';
			execute 'create index transaction_billing_index on '||schema_name||'.billing_rated_transaction using btree (usage_date, invoice_id, wallet_id, invoice_sub_category_id);';
			
			-- Create default partition
			execute 'create table '||schema_name||'.billing_rated_transaction_default partition of '||schema_name||'.billing_rated_transaction default;';
			
			-- Create required partitions. Number of partitions is calculated between min and max partition date based on a frequency
			IF _min_date IS NOT NULL and frequency IS NOT NULL THEN
			
			  _partitions_number := _max_date - _min_date;
			  
			  IF frequency = 'M' THEN
			    _partitions_number := _partitions_number/30;
			  END IF;
			            
			  IF frequency = 'Y' THEN
			    _partitions_number := _partitions_number/365;
			  END IF;
			        
			  IF frequency = 'W' THEN
			    _partitions_number := _partitions_number/7;
			  END IF;
			
			
			  PERFORM create_partitions(schema_name || '.billing_rated_transaction', to_char(_min_date,'YYYY_MM_DD'), frequency, _partitions_number+1);
			END IF;
			
			-- Populate with old data
			execute 'insert into '||schema_name||'.billing_rated_transaction select * from '||schema_name||'.billing_rated_transaction_tmp;';
					
			-- Drop temp data table
			execute 'drop table '||schema_name||'.billing_rated_transaction_tmp cascade;';
			
			-- Recreate sequence
			execute 'CREATE SEQUENCE IF NOT EXISTS '|| schema_name || '.billing_rated_transaction_seq START '||_seq_value||';';
			
			    END;
			$$ LANGUAGE plpgsql;
			    
			        ]]>
        </createProcedure>
        
        <createProcedure><![CDATA[
        
			CREATE OR REPLACE FUNCTION switch_billing_wallet_operation_to_partition(schema_owner text, schema_name text, frequency text) RETURNS void AS $$
			
			-- Function to replace billing_wallet_operation table with a partitioned table. Preserves existing data.
			-- Param1 : schema_name => name of the schema where table is located.
			-- Param2 : frequency => interval of partionning ( Y for years, M for monthes, W for weeks). If provided, partitions will be created to span the current data in 
			
			DECLARE
			  _min_date date;
			  _max_date date;
			  _seq_value bigint;
			  _partitions_number int;
			
			BEGIN
			
			-- Find values for partition creation and sequence recreation
			execute 'select min(operation_date), max(operation_date) from ' || schema_name || '.billing_wallet_operation ' into _min_date, _max_date;
			execute 'select nextval(''' || schema_name || '.billing_wallet_operation_seq'')' into _seq_value;
			
			RAISE NOTICE 'min date is % max date is %', _min_date, _max_date;
			
			-- Rename existing table to a temp table
			execute 'alter table ' || schema_name || '.billing_wallet_operation rename to billing_wallet_operation_tmp;';
			execute 'alter index ' || schema_name || '.billing_wallet_operation_pkey rename to billing_wallet_operation_pkey_tmp;';
			execute 'alter index ' || schema_name || '.billing_wallet_operation_index rename to billing_wallet_operation_index_tmp;';
			execute 'alter index ' || schema_name || '.billing_wallet_operation_status rename to billing_wallet_operation_status_tmp;';
			
			-- Create new partitioned table
			execute 'create table ' || schema_name || '.billing_wallet_operation(
			      operation_type character varying(31) not null,
				  id bigint not null,
				  version integer,
				  created timestamp without time zone not null,
				  updated timestamp without time zone,
				  code character varying(255) not null,
				  description character varying(255),
				  amount_tax numeric(23,12),
				  amount_with_tax numeric(23,12),
				  amount_without_tax numeric(23,12),
				  end_date timestamp without time zone,
				  offer_code character varying(255),
				  operation_date timestamp without time zone,
				  parameter_1 character varying(255),
				  parameter_2 character varying(255),
				  parameter_3 character varying(255),
				  quantity numeric(23,12),
				  start_date timestamp without time zone,
				  status character varying(255),
				  subscription_date timestamp without time zone,
				  tax_percent numeric(23,12),
				  credit_debit_flag character varying(255),
				  unit_amount_tax numeric(23,12),
				  unit_amount_with_tax numeric(23,12),
				  unit_amount_without_tax numeric(23,12),
				  creator character varying(100),
				  updater character varying(100),
				  aggregate_serv_id bigint,
				  charge_instance_id bigint not null,
				  counter_id bigint,
				  currency_id bigint,
				  priceplan_id bigint,
				  reratedwalletoperation_id bigint,
				  seller_id bigint not null,
				  wallet_id bigint,
				  reservation_id bigint,
				  invoicing_date timestamp without time zone,
				  input_quantity numeric(23,12),
				  input_unit_description character varying(20),
				  rating_unit_description character varying(20),
				  edr_id bigint,
				  order_number character varying(100),
				  parameter_extra text,
				  raw_amount_without_tax numeric(23,12),
				  raw_amount_with_tax numeric(23,12),
				  invoice_sub_category_id bigint,
				  subscription_id bigint,
				  tax_id bigint,
				  rated_transaction_id bigint,
				  service_instance_id bigint,
				  offer_id bigint,
				  constraint billing_wallet_operation_pkey primary key (id, operation_date),
				  constraint fk_32r2ed0015tnd2pp5196vcqpy foreign key (reservation_id)
				      references '||schema_name||'.billing_reservation (id) match simple
				      on update no action on delete no action,
				  constraint fk_5htics7k9v44an8ap11wivraf foreign key (wallet_id)
				      references '||schema_name||'.billing_wallet (id) match simple
				      on update no action on delete no action,
				  constraint fk_60qrdadyj5wvmyii1einfb2lo foreign key (counter_id)
				      references '||schema_name||'.billing_counter (id) match simple
				      on update no action on delete no action,
				  constraint fk_75hyldnus6ti0y40vwcl49ued foreign key (charge_instance_id)
				      references '||schema_name||'.billing_charge_instance (id) match simple
				      on update no action on delete no action,
				  constraint fk_awekpkm39bhaqrf2k2gwvd4p5 foreign key (aggregate_serv_id)
				      references '||schema_name||'.billing_service_instance (id) match simple
				      on update no action on delete no action,
				  constraint fk_billing_wallet_operation_billing_invoice_sub_cat foreign key (invoice_sub_category_id)
				      references '||schema_name||'.billing_invoice_sub_cat (id) match simple
				      on update no action on delete no action,
				  constraint fk_billing_wallet_operation_offer_template foreign key (offer_id)
				      references '||schema_name||'.cat_offer_template (id) match simple
				      on update no action on delete no action,
				  constraint fk_f0v21kf4sbdcq1wwqsxmb5tsk foreign key (priceplan_id)
				      references '||schema_name||'.cat_price_plan_matrix (id) match simple
				      on update no action on delete no action,
				  constraint fk_hg1a5impet68w8a37dehlnib0 foreign key (seller_id)
				      references '||schema_name||'.crm_seller (id) match simple
				      on update no action on delete no action,
				  constraint fk_rt_charge foreign key (charge_instance_id)
				      references '||schema_name||'.billing_charge_instance (id) match simple
				      on update no action on delete no action,
				  constraint fk_t98kqb1prnfw6scvudimx1u0q foreign key (currency_id)
				      references '||schema_name||'.adm_currency (id) match simple
				      on update no action on delete no action,
				  constraint fk_wallet_operation_service_instance foreign key (service_instance_id)
				      references '||schema_name||'.billing_service_instance (id) match simple
				      on update no action on delete no action,
				  constraint fk_wo_tax foreign key (tax_id)
				      references '||schema_name||'.billing_tax (id) match simple
				      on update no action on delete no action
			) partition by range (operation_date) ';
			
			-- execute 'alter table ' || schema_name || '.billing_wallet_operation owner to meveo;';
			
			-- Create indexes
			execute 'create index billing_wallet_operation_o_date on ' || schema_name || '.billing_wallet_operation using btree (operation_date);';
			execute 'create index billing_wallet_operation_index on ' || schema_name || '.billing_wallet_operation using btree (operation_date, wallet_id, charge_instance_id);';
			execute 'create index billing_wallet_operation_status on ' || schema_name || '.billing_wallet_operation using btree (operation_date, status);';
			
			-- Create default partition
			execute 'create table '||schema_name||'.billing_wallet_operation_default partition of '||schema_name||'.billing_wallet_operation default;';
			execute 'alter table '||schema_name||'.billing_wallet_operation_default owner to '||schema_owner||';';
			
			-- Create required partitions. Number of partitions is calculated between min and max partition date based on a frequency
			IF _min_date IS NOT NULL and frequency IS NOT NULL THEN
			
			  _partitions_number := _max_date - _min_date;
			  
			  IF frequency = 'M' THEN
			    _partitions_number := _partitions_number/30;
			  END IF;
			            
			  IF frequency = 'Y' THEN
			    _partitions_number := _partitions_number/365;
			  END IF;
			        
			  IF frequency = 'W' THEN
			    _partitions_number := _partitions_number/7;
			  END IF;
			
			  PERFORM create_partitions(schema_name || '.billing_wallet_operation', to_char(_min_date,'YYYY_MM_DD'), frequency, _partitions_number+1);
			END IF;
			
			-- Populate with old data
			execute 'insert into ' || schema_name || '.billing_wallet_operation select * from ' || schema_name || '.billing_wallet_operation_tmp;';

			-- Drop temp data table
			execute 'drop table ' || schema_name || ' .billing_wallet_operation_tmp cascade;';
			
			-- Recreate sequence
			execute 'CREATE SEQUENCE IF NOT EXISTS '|| schema_name || '.billing_wallet_operation_seq START '||_seq_value||';';
			
			    END;
			$$ LANGUAGE plpgsql;
			        ]]>
        </createProcedure>
    
    </changeSet>
    
</databaseChangeLog> 
